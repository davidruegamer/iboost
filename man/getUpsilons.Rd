% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getUpsilons.R
\name{getUpsilons}
\alias{getUpsilons}
\title{Compute residual matrix for boosting object}
\usage{
getUpsilons(mod, otherSelCourse = NULL, last = FALSE, listFun = kronecker,
  returnUpsOnly = TRUE)
}
\arguments{
\item{mod}{an object of class \code{mboost}.}

\item{otherSelCourse}{either \code{NULL} or \code{numeric}. If \code{NULL} Upsilon is computed for
\code{selected(mod)}, otherwise for otherSelCourse}

\item{last}{logical; whether to return only Upsilon for the last selection step. If FALSE, a list of
Upsilons for all iterations is returned}

\item{listFun}{function; used to combine design matrices, which are build with 
baselearner operators such as \code{\%X\%}.}

\item{returnUpsOnly}{logical; if FALSE, the hat matrices are also returned.}
}
\value{
Returns a list of length \code{mstop(mod)+1} with residual matrices of size \code{length(mod$response)}.
}
\description{
Compute residual matrix for boosting object
}
\examples{
if(require("mboost") & require("TH.data")){
data("bodyfat", package = "TH.data")
mod <- mboost(DEXfat ~ bols(waistcirc) + bbs(hipcirc), data = bodyfat)
Ups <- getUpsilons(mod)
# check result
cbind(mod[100]$resid()[1:10],
(Ups[[length(Ups)]]\%*\%(mod$response-mod$offset))[1:10]
)
}
}
